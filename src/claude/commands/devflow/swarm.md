---
description: Execute a single task through the complete lifecycle - Design, Implement, and Review in an isolated worktree
---

# Swarm Command - Single Task Lifecycle

Execute a single task from design through implementation to review. Works in an isolated worktree and produces a PR ready for merge.

## Usage

```
/swarm <task description>
```

Or with explicit context:
```
/swarm Implement user authentication with JWT tokens
```

For multi-task parallel execution, use `/swarm-orchestrator` instead.

---

## Input

You receive:
- `TASK_DESCRIPTION`: What to implement
- `WORKTREE_DIR`: Isolated worktree path (e.g., `.worktrees/task-1`)
- `TASK_BRANCH`: Branch name for this task (e.g., `swarm/release-1/task-1`)
- `TARGET_BRANCH`: Branch to create PR against (e.g., `release/swarm-2025-01-15`)
- `TASK_ID`: Identifier for this task (e.g., `task-1`)

If not provided, generate defaults:

```bash
TIMESTAMP=$(date +%Y-%m-%d_%H%M)
TASK_ID="task-${TIMESTAMP}"
TASK_BRANCH="swarm/${TASK_ID}"
TARGET_BRANCH=$(git branch --show-current)
WORKTREE_DIR=".worktrees/${TASK_ID}"

# Create worktree
mkdir -p .worktrees
git worktree add -b "${TASK_BRANCH}" "${WORKTREE_DIR}" "${TARGET_BRANCH}"
```

## Your Mission

Execute the complete task lifecycle:

```
DESIGN â†’ IMPLEMENT â†’ REVIEW â†’ REPORT
```

**Output**: A PR that's ready for merge (or issues that need addressing).

---

## Phase 1: Design

Spawn the Design agent to create a detailed implementation plan.

```
Task tool with subagent_type="Design":

"Create implementation design for: ${TASK_DESCRIPTION}

Working directory: ${WORKTREE_DIR}
Target branch: ${TARGET_BRANCH}

Explore the codebase, understand existing patterns, and create a detailed
implementation plan. Save the design to: .docs/design/${TASK_ID}-design.md

Be thorough - this plan will be executed in the next phase."
```

### Design Output Expected

The Design agent will:
1. Launch 3 parallel Explore agents (Architecture, Integration, Reusable Code)
2. Synthesize findings and clarify ambiguities
3. Launch 2 Plan agents (Create Plan + Critical Review)
4. Persist design document

**Wait for Design agent to complete before proceeding.**

### Verify Design

```bash
# Ensure design document exists
DESIGN_FILE=".docs/design/${TASK_ID}-design.md"
if [ ! -f "$DESIGN_FILE" ]; then
    echo "ERROR: Design document not created"
    exit 1
fi

echo "âœ… Design complete: $DESIGN_FILE"
```

---

## Phase 2: Implement

Execute the implementation plan in the worktree.

### 2.1: Change to Worktree

```bash
cd "${WORKTREE_DIR}"
git status
```

### 2.2: Read and Execute Plan

Read the design document and implement each step:

```bash
cat ".docs/design/${TASK_ID}-design.md"
```

**Implementation Rules:**
- Follow the plan step by step
- Create/modify files as specified
- Follow existing code patterns identified in design
- Write tests for new functionality
- Keep changes focused on the task

### 2.3: Run Tests

```bash
# Run relevant tests
npm test  # or appropriate test command

# If tests fail, debug and fix before continuing
```

### 2.4: Commit Changes

Create atomic, well-described commits:

```bash
# Stage changes
git add -A

# Create commit with descriptive message
git commit -m "$(cat <<'EOF'
feat: ${TASK_SUMMARY}

${DETAILED_DESCRIPTION}

Task: ${TASK_ID}
Design: .docs/design/${TASK_ID}-design.md

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

### 2.5: Push and Create PR

```bash
# Push branch
git push -u origin "${TASK_BRANCH}"

# Create PR against target branch
gh pr create \
    --base "${TARGET_BRANCH}" \
    --head "${TASK_BRANCH}" \
    --title "feat: ${TASK_SUMMARY}" \
    --body "$(cat <<'EOF'
## Summary

${TASK_DESCRIPTION}

## Changes

${LIST_OF_CHANGES}

## Design Document

See: `.docs/design/${TASK_ID}-design.md`

## Testing

- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing completed

---

Task ID: ${TASK_ID}
ðŸ¤– Generated by DevFlow Swarm
EOF
)"

# Capture PR number
PR_NUMBER=$(gh pr view --json number -q '.number')
PR_URL=$(gh pr view --json url -q '.url')

echo "âœ… PR created: #${PR_NUMBER}"
echo "   URL: ${PR_URL}"
```

---

## Phase 3: Review

Spawn the CodeReview agent to validate the implementation.

```
Task tool with subagent_type="CodeReview":

"Review PR #${PR_NUMBER} for task: ${TASK_DESCRIPTION}

This PR implements ${TASK_ID} as part of a swarm release.
The implementation follows the design at: .docs/design/${TASK_ID}-design.md

Run all relevant audits and create PR line comments for issues found.
Report back with: approval status, blocking issues, and recommendations."
```

### Review Output Expected

The CodeReview agent will:
1. Run relevant audits (Security, Architecture, Tests, etc.)
2. Create PR line comments for issues
3. Generate review summary
4. Provide merge recommendation

**Wait for CodeReview agent to complete.**

### Handle Review Results

```markdown
If APPROVED:
    â†’ Task complete, ready for merge

If CHANGES_REQUESTED:
    â†’ Parse feedback
    â†’ Address blocking issues
    â†’ Re-run tests
    â†’ Update PR
    â†’ Request re-review (loop back to Phase 3)

If BLOCKED:
    â†’ Report blocking issues to orchestrator
    â†’ Do not proceed
```

### Review Loop (if needed)

If changes are requested:

1. Read the review feedback
2. Address each blocking issue
3. Commit fixes:
   ```bash
   git add -A
   git commit -m "fix: address review feedback for ${TASK_ID}"
   git push
   ```
4. Re-spawn CodeReview agent
5. Repeat until approved

**Maximum review iterations**: 3 (after that, escalate to user)

---

## Phase 4: Report

Return results to the user:

```markdown
## ðŸ”„ Swarm Task Complete: ${TASK_ID}

### Task
${TASK_DESCRIPTION}

### Status: ${STATUS}

| Metric | Value |
|--------|-------|
| PR Number | #${PR_NUMBER} |
| PR URL | ${PR_URL} |
| Design Doc | .docs/design/${TASK_ID}-design.md |
| Commits | ${NUM_COMMITS} |
| Files Changed | ${NUM_FILES} |
| Review Status | ${REVIEW_STATUS} |
| Review Iterations | ${NUM_REVIEWS} |

### Files Touched
${LIST_OF_FILES}

### Blocking Issues (if any)
${BLOCKING_ISSUES}

### Ready for Merge: ${YES_NO}
```

---

## Error Handling

### Design Failure

If Design agent fails or times out:

```markdown
## âŒ Design Phase Failed

**Task**: ${TASK_ID}
**Error**: ${ERROR_MESSAGE}

**Options**:
1. Retry Design phase
2. Escalate to user for manual design
3. Skip task

**Recommendation**: ${RECOMMENDATION}
```

### Implementation Failure

If implementation fails (tests don't pass, build breaks):

```markdown
## âŒ Implementation Failed

**Task**: ${TASK_ID}
**Phase**: Implementation
**Error**: ${ERROR_MESSAGE}

**Debug Info**:
- Last command: ${COMMAND}
- Exit code: ${EXIT_CODE}
- Output: ${OUTPUT}

**Options**:
1. Spawn Debug agent to investigate
2. Retry implementation
3. Escalate to user
4. Skip task

**Recommendation**: ${RECOMMENDATION}
```

### Review Rejection (after max iterations)

```markdown
## âš ï¸ Review Not Passing

**Task**: ${TASK_ID}
**PR**: #${PR_NUMBER}
**Review Iterations**: ${NUM_REVIEWS} (max reached)

**Remaining Issues**:
${LIST_OF_ISSUES}

**Options**:
1. Escalate to user for manual fixes
2. Merge with known issues (not recommended)
3. Abandon task

**Recommendation**: Escalate to user
```

---

## Cleanup (if standalone)

If running as standalone (not part of orchestrator):

```bash
# After PR is merged, cleanup worktree
git worktree remove "${WORKTREE_DIR}" --force
git worktree prune
git branch -d "${TASK_BRANCH}" 2>/dev/null

echo "âœ… Cleanup complete"
```

---

## Principles

1. **Single responsibility** - One task, one lifecycle
2. **Leverage existing agents** - Design and CodeReview handle complexity
3. **Isolated execution** - Worktree prevents interference
4. **Complete lifecycle** - Design â†’ Implement â†’ Review
5. **Honest reporting** - Surface all issues, don't hide failures
6. **Retry with limits** - Attempt recovery, but escalate if stuck
